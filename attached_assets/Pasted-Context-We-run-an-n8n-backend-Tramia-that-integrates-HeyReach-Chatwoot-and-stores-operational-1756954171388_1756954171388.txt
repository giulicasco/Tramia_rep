Context

We run an n8n backend (“Tramia”) that integrates HeyReach + Chatwoot and stores operational data in Postgres. Keep our existing frontend unchanged. Convert the server/ into a Backend-for-Frontend (BFF): every /api/* call should be forwarded to an n8n Webhook and the response returned as-is to the UI. Never expose third-party tokens to the browser.

The n8n webhooks validate a shared secret via header x-internal-key. We already configured this server-side.Build & Run in Replit Deployments

Build command: npm run build

Run command: npm run start

The server must listen on process.env.PORT.

// ensure in your server entry:
const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Server listening on :${port}`));


Disable “Create production database upon deployment” (we use Neon).

1) Add the n8n client

Create server/n8n.ts:

import fetch from "node-fetch";

const N8N_BASE = process.env.N8N_BASE!;
const INTERNAL_KEY = process.env.INTERNAL_KEY!;

export async function callN8N(path: string, payload?: any, init: RequestInit = {}) {
  const url = `${N8N_BASE}${path}`;
  const method = init.method || (payload ? "POST" : "GET");
  const headers = {
    "content-type": "application/json",
    "x-internal-key": INTERNAL_KEY,
    ...(init.headers || {}),
  };
  const res = await fetch(url, {
    method,
    headers,
    body: payload ? JSON.stringify(payload) : undefined,
  });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`n8n ${res.status}: ${text || res.statusText}`);
  }
  return res.json();
}

2) Replace mock routes with n8n calls

Edit server/routes.ts and forward each /api/* endpoint to the matching n8n webhook. Return the JSON as-is.

Reports
import { callN8N } from "./n8n";

// GET /api/reports/overview?from&to
app.get("/api/reports/overview", async (req, res) => {
  try {
    const { from, to } = req.query;
    const data = await callN8N(
      `/webhook/tramia-reports-overview?from=${from||""}&to=${to||""}`,
      undefined,
      { method: "GET" }
    );
    res.json(data); // { kpis:{...}, series:[...] }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch overview" });
  }
});

// (same idea for other report routes you have in the UI)
// GET /api/reports/agents      -> /webhook/tramia-reports-agents
// GET /api/reports/funnel      -> /webhook/tramia-reports-funnel
// GET /api/reports/costs       -> /webhook/tramia-reports-costs
// GET /api/reports/ops         -> /webhook/tramia-reports-ops

Conversations
// GET /api/conversations
app.get("/api/conversations", async (_req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-conversations-list`, undefined, { method: "GET" });
    res.json(data); // [ { id, user_id, name, chatwoot_conversation_id, ... } ]
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch conversations" });
  }
});

// GET /api/conversations/:id
app.get("/api/conversations/:id", async (req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-conversations-get?id=${encodeURIComponent(req.params.id)}`, undefined, { method: "GET" });
    res.json(data); // { id, timeline:[...] }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch conversation" });
  }
});

// POST /api/conversations/:id/actions
app.post("/api/conversations/:id/actions", async (req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-conv-action`, { id: req.params.id, ...req.body });
    res.json(data); // { ok:true }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to perform action" });
  }
});

Jobs (queue)
// GET /api/jobs
app.get("/api/jobs", async (_req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-jobs-list`, undefined, { method: "GET" });
    res.json(data);
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch jobs" });
  }
});

// POST /api/jobs/:id/retry
app.post("/api/jobs/:id/retry", async (req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-jobs-retry`, { id: req.params.id });
    res.json(data); // { ok:true }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to retry job" });
  }
});

// (optional)
// POST /api/jobs/:id/cancel   -> /webhook/tramia-jobs-cancel
// POST /api/jobs/:id/reassign -> /webhook/tramia-jobs-reassign

Agents (prompts & test)
// GET /api/agents
app.get("/api/agents", async (_req, res) => {
  try {
    const agents = await callN8N(`/webhook/tramia-agents-get`, undefined, { method:"GET" });
    res.json(agents); // [{ agentType, system, outputSchema, paramsJson, version }, ...]
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch agents" });
  }
});

// PUT /api/agents/:agentType
app.put("/api/agents/:agentType", async (req, res) => {
  try {
    const saved = await callN8N(`/webhook/tramia-agents-update`, { agentType: req.params.agentType, ...req.body });
    res.json(saved); // { ok:true, version }
  } catch (e:any) {
    res.status(400).json({ message: e.message || "Invalid agent configuration" });
  }
});

// POST /api/agents/:agentType/test
app.post("/api/agents/:agentType/test", async (req, res) => {
  try {
    const result = await callN8N(`/webhook/tramia-agents-test`, { agentType: req.params.agentType, input: req.body?.input });
    res.json(result); // { success, output, tokensUsed, estimatedCost }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Agent test failed" });
  }
});

Knowledge
// GET /api/knowledge
app.get("/api/knowledge", async (_req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-knowledge-list`, undefined, { method:"GET" });
    res.json(data);
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch knowledge" });
  }
});

// POST /api/knowledge
app.post("/api/knowledge", async (req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-knowledge-create`, req.body);
    res.json(data); // { id, status:'queued' }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to create knowledge item" });
  }
});

Integrations (Chatwoot test)
app.post("/api/integrations/chatwoot/test", async (_req, res) => {
  try {
    const result = await callN8N(`/webhook/tramia-cw-test`, {
      base: process.env.CHATWOOT_BASE,
      accountId: parseInt(process.env.CHATWOOT_ACCOUNT_ID!, 10),
      inboxIdentifier: process.env.CHATWOOT_INBOX_IDENTIFIER,
      token: process.env.CHATWOOT_API_TOKEN
    });
    res.json(result); // { success, contactId, conversationId }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Chatwoot test failed" });
  }
});

// (optional) HeyReach test
app.post("/api/integrations/heyreach/test", async (_req, res) => {
  try {
    const result = await callN8N(`/webhook/tramia-hr-check`, {
      apiKey: process.env.HEYREACH_API_KEY
    });
    res.json(result);
  } catch (e:any) {
    res.status(500).json({ message: e.message || "HeyReach test failed" });
  }
});

Settings (examples)
// GET /api/settings/gating
app.get("/api/settings/gating", async (_req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-settings-gating-get`, undefined, { method:"GET" });
    res.json(data); // { hrLeadsAiEnabled, externalLeadsAiEnabled, muteWindow }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to fetch gating" });
  }
});

// PUT /api/settings/gating
app.put("/api/settings/gating", async (req, res) => {
  try {
    const data = await callN8N(`/webhook/tramia-settings-gating-set`, req.body);
    res.json(data); // { ok:true }
  } catch (e:any) {
    res.status(500).json({ message: e.message || "Failed to save gating" });
  }
});

3) Security requirements

Every call to n8n must include header x-internal-key: process.env.INTERNAL_KEY.

Never expose secrets to the browser. If the client needs CW deep-links, either:

Build them server-side and return them in the JSON, or

Expose only VITE_CHATWOOT_BASE and VITE_CHATWOOT_ACCOUNT_ID (non-secrets).

4) Smoke tests after deployment

GET /api/reports/overview → Should return JSON from /webhook/tramia-reports-overview.

GET /api/conversations, GET /api/jobs → Should render lists.

In the UI, Integrations → Chatwoot Test → Should return { success:true, contactId, conversationId }.

Click deep-links to Chatwoot:
${CHATWOOT_BASE}/app/accounts/${CHATWOOT_ACCOUNT_ID}/conversations/${chatwoot_conversation_id} opens the conversation.

If you receive 401 from n8n, it means the webhook workflow is correctly protected and the header wasn’t sent; verify callN8N sets x-internal-key from process.env.INTERNAL_KEY.

Definition of done

Frontend stays intact; server/ acts as a thin adapter.

All /api/* routes forward to the corresponding /webhook/tramia-* in n8n and return the JSON as-is.

Server listens on process.env.PORT.

No secrets are exposed to the client.

Chatwoot deep-links open the right conversation in account 1 and inbox PLwNikxXNaQm4B3GxoJbryin (API channel).