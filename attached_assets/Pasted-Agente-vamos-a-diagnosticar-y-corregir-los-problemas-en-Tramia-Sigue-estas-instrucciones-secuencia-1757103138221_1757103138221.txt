Agente, vamos a diagnosticar y corregir los problemas en Tramia. Sigue estas instrucciones secuencialmente.

Fase 1: Diagnóstico y Corrección del Flujo de Datos (Drizzle/BFF/TanStack Query)
El objetivo es identificar el punto exacto donde se pierden los datos entre Neon y React.

Paso 1.1: Instrumentación del BFF (Express + Drizzle)

Necesitamos interceptar los datos en el servidor Express para ver qué está devolviendo Drizzle ORM.

Instrucción: Identificar y Loguear un Endpoint Crítico.
Localiza uno de los endpoints que debería devolver datos pero muestra datos dummy. Usemos /api/activity/recent-conversations como ejemplo. Añade logs detallados justo después de la consulta de Drizzle.

Ejemplo (Ajusta según tu código real en el servidor Express):

JavaScript

// Dentro del manejador de la ruta (e.g., server/routes/activity.js)

router.get('/recent-conversations', requireAuth, async (req, res) => {
    console.log("[DIAGNOSTICO BFF] Solicitando /api/activity/recent-conversations");
    try {
        // === LA CONSULTA DE DRIZZLE EXISTENTE VA AQUÍ ===
        // const conversations = await db.select()...
        // ================================================

        // >>> AÑADIR ESTOS LOGS <<<
        console.log("[DIAGNOSTICO BFF] Resultado crudo de Drizzle:", JSON.stringify(conversations, null, 2));

        if (!conversations || conversations.length === 0) {
            console.log("[DIAGNOSTICO BFF] Advertencia: Drizzle devolvió un array vacío o nulo.");
        }

        res.json(conversations);

    } catch (error) {
        console.error("[DIAGNOSTICO BFF] ERROR en Drizzle/Postgres:", error.message, error.stack);
        // IMPORTANTE: Devolver un 500. Si devuelves un 200 con datos vacíos por error, TanStack Query lo cacheará como éxito.
        res.status(500).json({ error: 'Internal Server Error' });
    }
});
Instrucción: Análisis de Logs (Acción del Usuario).
(Usuario: Pídele al agente que implemente esto, haz Redeploy y revisa los Logs de Replit).

Si ves un ERROR en Drizzle/Postgres (e.g., "relation does not exist" o "column not found"): El esquema de la DB no está sincronizado con Drizzle.

Instrucción al Agente: Asegúrate de que las migraciones de Drizzle se estén ejecutando correctamente en el despliegue. Verifica si existe un script db:push o db:migrate en package.json y asegúrate de que se ejecute antes de npm run start, o ejecuta manualmente npx drizzle-kit push:pg (si usas push en lugar de migraciones).

Si ves Advertencia: Drizzle devolvió un array vacío (pero hay datos en Neon): La conexión funciona, pero la lógica de la consulta (cláusulas where, joins) es incorrecta.

Instrucción al Agente: Revisa la lógica de la consulta en el controlador y asegúrate de que los filtros no sean demasiado restrictivos.

Si ves los datos correctos en Resultado crudo de Drizzle: El problema está en el Frontend (Pasar al Paso 1.2).

Paso 1.2: Verificación del Frontend (React + TanStack Query)

Si el BFF envía los datos, pero el FE no los muestra.

Instrucción: Auditar el Hook de TanStack Query.
Localiza el hook que consume el endpoint (e.g., useRecentConversations.ts).

TypeScript

// Ejemplo en src/hooks/useRecentConversations.ts
export const useRecentConversations = () => {
  return useQuery({
    queryKey: ['recentConversations'],
    queryFn: async () => {
      const response = await fetch('/api/activity/recent-conversations');
      // CRUCIAL: TanStack Query necesita que se lance un error si la respuesta no es OK.
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      const data = await response.json();
      // >>> AÑADIR ESTE LOG <<<
      console.log("[DIAGNOSTICO FE] Datos recibidos en TanStack Query:", data);
      return data;
    },
    // >>> EL FIX POTENCIAL <<<
    // Si usas initialData con datos dummy, puede impedir que se muestren los datos reales si el caché es agresivo.
    // initialData: DUMMY_DATA, // <- Comenta esto temporalmente para diagnóstico.
  });
};
Instrucción: Auditar el Componente de Renderizado.
Verifica que el componente no esté priorizando los datos dummy sobre los datos reales (data).

TypeScript

// Ejemplo en src/components/ConversationsList.tsx
const ConversationsList = () => {
  const { data: conversations, isLoading, isError } = useRecentConversations();

  if (isLoading) return <Skeleton />;
  if (isError) return <div>Error cargando datos</div>;

  // EL FIX: Asegúrate de usar los datos de la API.
  // const displayData = DUMMY_CONVERSATIONS; // INCORRECTO
  const displayData = conversations || []; // CORRECTO

  // ... renderizado
};
Fase 2: Corrección del Dark Mode (TailwindCSS + shadcn/ui)
Dado que usas shadcn/ui, el sistema se basa en variables CSS. Si el fondo no cambia a negro y los textos a blanco, las variables no están configuradas o aplicadas correctamente.

Paso 2.1: Verificar la Configuración de Variables CSS (Crucial para shadcn/ui)

Instrucción: Verificar tailwind.config.js (o .ts).
Asegúrate de que esté configurado: darkMode: 'class',.

Instrucción: Verificar el CSS Global (e.g., src/index.css o src/globals.css).
Este archivo define las variables CSS. Asegúrate de que las definiciones para .dark existan y usen los colores deseados (Carbon #0B0F14).

CSS

@layer base {
  :root {
    /* Light mode variables (ejemplo: fondo blanco) */
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    /* ... otras variables como primary, secondary, etc. ... */
  }

  .dark {
    /* Dark mode variables (ejemplo: fondo Carbon, texto claro) */
    /* HSL aproximado para #0B0F14 (Carbon) */
    --background: 225 29% 6%; 
    /* HSL para un blanco suave */
    --foreground: 0 0% 98%; 
    /* ... asegúrate que todas las variables tengan su equivalente oscuro ... */
  }
}
Paso 2.2: Aplicación de Estilos Globales (El Fix más común)

El contenedor principal de la aplicación debe usar estas variables para que el tema se aplique globalmente.

Instrucción: Verificar el Layout Principal (e.g., src/App.tsx o src/components/Layout.tsx).
Asegúrate de que el div principal tenga las clases bg-background y text-foreground.

TypeScript

// En el componente Layout principal
<ThemeProvider>
    <div className="min-h-screen bg-background text-foreground transition-colors">
      {/* Todo el contenido de la aplicación va aquí */}
    </div>
</ThemeProvider>
Si esto falta, el fondo y el color de texto por defecto nunca cambiarán, incluso si el toggle funciona.

Paso 2.3: Verificación del Mecanismo de Toggle

Asegúrate de que el ThemeProvider esté efectivamente añadiendo la clase dark al elemento raíz del HTML.

Instrucción: Auditar el ThemeProvider (usualmente en src/context/ThemeContext.tsx o src/components/theme-provider.tsx).
Verifica el useEffect que aplica la clase al documentElement.

TypeScript

useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("light", "dark");
    // Asegúrate de que esta línea se ejecute correctamente
    root.classList.add(theme);
}, [theme]);