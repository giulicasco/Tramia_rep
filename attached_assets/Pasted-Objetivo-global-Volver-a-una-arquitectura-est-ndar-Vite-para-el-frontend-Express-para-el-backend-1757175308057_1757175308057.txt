Objetivo global

Volver a una arquitectura estándar: Vite para el frontend + Express para el backend.

En deploy: build del cliente y del servidor, y correr Node sobre JS compilado (nada de tsx/bun/esbuild ad-hoc).

Reparar UI/UX (tema, support button, recent inbound, conversations, job queue con polling suave).

0) Limpieza de cambios peligrosos

Eliminá cualquier wrapper o archivo creado manualmente en node_modules/.bin/tsx.

Revertí todo el código agregado en server/index.ts relacionado con:

páginas HTML “fallback”,

“esbuild transpilation on-the-fly”,

bun build o ejecución con bun,

relax de validación que rompa producción,

cualquier “static server” improvisado que sirva /src/*.tsx directamente.

Dejá un server/index.ts limpio que:

En production sirva estático desde dist/public,

En development use Vite middleware (si lo necesitás localmente; en Replit deploy vamos con “production”).

Si no podés revertir con git, reemplazá el archivo por el contenido que te doy en el paso 3.

1) Dependencias (instalar bien)

Ejecutá:

# Prod deps (server)
npm i express helmet cors cookie-parser jsonwebtoken express-rate-limit pg

# FE y build
npm i -D typescript vite @vitejs/plugin-react @types/node @types/express concurrently rimraf ts-node ts-node-dev

# FE runtime
npm i react react-dom @tanstack/react-query framer-motion

# Tailwind (si ya está, npm lo mantendrá)
npm i -D tailwindcss postcss autoprefixer

2) Scripts de package.json

Abrí package.json y dejá exactamente estos scripts (adaptá si ya tenés alguno, pero mantené esta intención):

{
  "scripts": {
    "dev": "concurrently -k \"ts-node-dev --respawn --transpile-only server/index.ts\" \"vite\"",
    "build": "rimraf dist && npm run build:server && npm run build:client",
    "build:server": "tsc -p server/tsconfig.json",
    "build:client": "vite build",
    "start": "NODE_ENV=production node dist/server/index.js"
  }
}


Con esto no dependemos de tsx en deploy.
En Replit Deploy usaremos:
Build command: npm ci --include=dev && npm run build
Run command: npm run start

3) Server limpio y correcto
3.1 server/tsconfig.json

Crea/ajusta:

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "../dist/server",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "types": ["node"]
  },
  "include": ["./**/*.ts"]
}

3.2 vite.config.ts (raíz del repo)

Asegurate de que el build del FE vaya a dist/public:

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  root: 'client',
  build: {
    outDir: '../dist/public',
    emptyOutDir: true
  },
  server: {
    port: 5173
  }
})

3.3 server/index.ts (reemplazar contenido por este esqueleto sólido)

Integra todos tus endpoints existentes + los Plan Pro. Este esqueleto incluye: health, auth/me, overview con rango, recent inbound, conversations list, queue running y serve estático en prod.

import 'dotenv/config'
import express from 'express'
import helmet from 'helmet'
import cors from 'cors'
import cookieParser from 'cookie-parser'
import rateLimit from 'express-rate-limit'
import { Pool } from 'pg'
import path from 'path'

const app = express()
const pool = new Pool({ connectionString: process.env.DATABASE_URL })

// --- middlewares base ---
app.use(helmet())
app.use(cors({ origin: true, credentials: true }))
app.use(express.json({ limit: '1mb' }))
app.use(cookieParser())

// --- auth mínima (adaptá a tu lógica JWT si ya la tenías) ---
function requireAuth(req: any, res: any, next: any) {
  // si ya tenés tu cookie JWT, validala aquí; mientras tanto pasamos si existe cookie 'sid'
  if (!req.cookies?.sid) return res.status(401).json({ error: 'unauthorized' })
  // podés decodificar y guardar req.user si querés
  req.user = { email: 'partners@letsiatomate.com', role: 'admin' }
  next()
}

// --- utils rango ---
function parseRange(q: Record<string, any>) {
  const now = new Date()
  let from: Date | null = null, to: Date | null = null
  if (q.from && q.to) {
    const f = new Date(String(q.from)), t = new Date(String(q.to))
    if (!isNaN(+f) && !isNaN(+t) && f < t) { from = f; to = t }
  }
  if (!from || !to) {
    const r = String(q.range || '24h')
    const map: Record<string, number> = { '24h': 24, '7d': 24*7, '30d': 24*30 }
    const hours = map[r] ?? 24
    to = now; from = new Date(now.getTime() - hours*60*60*1000)
  }
  return { from, to }
}
function rangeLabel(q: Record<string, any>) {
  if (q.from && q.to) return 'Custom'
  return ({ '24h':'Last 24h','7d':'Last 7 days','30d':'Last 30 days' } as any)[q.range] || 'Last 24h'
}

// --- health ---
app.get('/healthz', async (_req, res) => {
  try { await pool.query('select 1'); res.json({ ok: true }) }
  catch (e: any) { res.status(500).json({ ok:false, error: e.message }) }
})

// --- me ---
app.get('/auth/me', requireAuth, (req: any, res) => {
  res.json({
    isAuthenticated: true,
    user: { email: req.user.email, role: req.user.role },
    organization: { id: 'default', name: 'Tramia', slug: 'main' },
  })
})

// --- API protegida ---
app.use('/api', requireAuth)

// OVERVIEW (Plan Pro: window + snapshot)
app.get('/api/metrics/overview', async (req, res) => {
  const { from, to } = parseRange(req.query)
  try {
    const winSql = `
    WITH
    accepted AS (
      SELECT count(*) AS c FROM public.hr_inbound_seen
      WHERE seen_at >= $1 AND seen_at < $2
    ),
    qualified AS (
      SELECT count(*) AS c FROM public.linkedin_jobs_incubadora
      WHERE qualified_at >= $1 AND qualified_at < $2
    ),
    scheduled AS (
      SELECT count(*) AS c FROM public.linkedin_jobs_incubadora
      WHERE scheduled_at >= $1 AND scheduled_at < $2
    ),
    ttfr AS (
      SELECT avg(extract(epoch from (
        COALESCE(first_ai_message_at, last_human_message_at)
        - COALESCE(first_lead_message_at, last_lead_message_at)
      ))) AS seconds
      FROM public.linkedin_jobs_incubadora
      WHERE COALESCE(first_lead_message_at, last_lead_message_at) >= $1
        AND COALESCE(first_lead_message_at, last_lead_message_at) <  $2
        AND (COALESCE(first_ai_message_at, last_human_message_at) IS NOT NULL)
    )
    SELECT
      COALESCE((SELECT c FROM accepted),0)   AS accepted_invitations,
      COALESCE((SELECT c FROM qualified),0)  AS qualified,
      COALESCE((SELECT c FROM scheduled),0)  AS scheduled,
      COALESCE((SELECT seconds FROM ttfr),0) AS ttfr_seconds;
    `
    const win = await pool.query(winSql, [from, to])

    const snapSql = `
    WITH
    active_leads AS (
      SELECT count(DISTINCT user_id) AS c
      FROM public.linkedin_jobs_incubadora
      WHERE status IN ('pending','processing','wait')
        AND (chatwoot_mode = 'ai-on' OR chatwoot_mode IS NULL)
    ),
    queue AS (
      SELECT
        sum((status='pending')::int) AS pending,
        sum((status='processing')::int) AS processing
      FROM public.linkedin_jobs_incubadora
    ),
    ai_status AS (
      SELECT
        sum((chatwoot_mode='ai-on')::int) AS ai_on,
        count(*) AS total
      FROM public.linkedin_jobs_incubadora
    )
    SELECT
      COALESCE((SELECT c FROM active_leads),0)   AS active_leads,
      COALESCE((SELECT pending FROM queue),0)    AS queue_pending,
      COALESCE((SELECT processing FROM queue),0) AS queue_processing,
      COALESCE((SELECT ai_on FROM ai_status),0)  AS ai_on,
      COALESCE((SELECT total FROM ai_status),0)  AS ai_total;
    `
    const snap = await pool.query(snapSql)

    res.json({ range: { from, to, label: rangeLabel(req.query) }, window: win.rows[0], snapshot: snap.rows[0] })
  } catch (e: any) { res.status(500).json({ error: e.message || 'metrics_failed' }) }
})

// Recent inbound (últimos 3 del lead en rango)
app.get('/api/activity/recent-inbound', async (req, res) => {
  const { from, to } = parseRange(req.query)
  try {
    const sql = `
    WITH base AS (
      SELECT j.id AS job_id, j.chatwoot_conversation_id, j.last_lead_message_at
      FROM public.linkedin_jobs_incubadora j
      WHERE j.chatwoot_conversation_id IS NOT NULL
        AND j.last_lead_message_at IS NOT NULL
        AND j.last_lead_message_at >= $1 AND j.last_lead_message_at < $2
      ORDER BY j.last_lead_message_at DESC
    )
    SELECT DISTINCT ON (b.chatwoot_conversation_id)
      b.chatwoot_conversation_id,
      b.job_id,
      b.last_lead_message_at AS at,
      (
        SELECT m.message
        FROM public.linkedin_jobs_memory_incubadora m
        WHERE m.session_id::text = b.chatwoot_conversation_id::text
          AND m.created_at <= b.last_lead_message_at
        ORDER BY m.created_at DESC
        LIMIT 1
      ) AS last_inbound
    FROM base b
    ORDER BY b.chatwoot_conversation_id, b.last_lead_message_at DESC
    LIMIT 3;
    `
    const { rows } = await pool.query(sql, [from, to])
    res.json(rows.map(r => ({
      conversation_id: r.chatwoot_conversation_id,
      job_id: r.job_id,
      last_message: r.last_inbound || 'No message',
      at: r.at
    })))
  } catch (e: any) { res.status(500).json({ error: e.message || 'recent_inbound_failed' }) }
})

// Conversations list
app.get('/api/conversations/list', async (req, res) => {
  const { from, to } = parseRange(req.query)
  try {
    const sql = `
    SELECT
      j.id AS job_id,
      j.chatwoot_conversation_id,
      j.user_id,
      j.status,
      j.agent_type,
      j.updated_at,
      j.last_lead_message_at,
      (
        SELECT m.message
        FROM public.linkedin_jobs_memory_incubadora m
        WHERE m.session_id::text = j.chatwoot_conversation_id::text
        ORDER BY m.created_at DESC
        LIMIT 1
      ) AS last_message
    FROM public.linkedin_jobs_incubadora j
    WHERE j.chatwoot_conversation_id IS NOT NULL
      AND j.updated_at >= $1 AND j.updated_at < $2
    ORDER BY j.updated_at DESC
    LIMIT 100;
    `
    const { rows } = await pool.query(sql, [from, to])
    res.json(rows)
  } catch (e: any) { res.status(500).json({ error: e.message || 'conversations_failed' }) }
})

// Running jobs
app.get('/api/queue/running', async (_req, res) => {
  try {
    const { rows } = await pool.query(`
      SELECT id, chatwoot_conversation_id, sender_account_id, agent_type,
             status, processing_started_at, priority, updated_at
      FROM public.linkedin_jobs_incubadora
      WHERE status = 'processing'
      ORDER BY processing_started_at DESC NULLS LAST
      LIMIT 100;
    `)
    res.json(rows)
  } catch (e: any) { res.status(500).json({ error: e.message || 'queue_running_failed' }) }
})

// --- Static PRODUCTION: dist/public ---
if (process.env.NODE_ENV === 'production') {
  const staticDir = path.resolve(__dirname, '../public')
  app.use(express.static(staticDir))
  app.get('*', (_req, res) => res.sendFile(path.join(staticDir, 'index.html')))
}

const port = Number(process.env.PORT || 5000)
app.listen(port, () => console.log(`BFF listening on :${port}`))

4) Frontend (React + Vite)
4.1 Build correcto

client vive en client/.

vite.config.ts ya apunta root:'client' y outDir:'../dist/public'.

4.2 Dark/Light funcional + remove Support “?”

Asegurate que tailwind.config.* tenga darkMode: 'class'.

En client/src/index.css, definí light en :root y dark en .dark (variables CSS completas).

ThemeProvider debe agregar/quitar class="dark" en <html> y persistir en localStorage (tramiai-theme).

En topbar.tsx, el botón llama a setTheme(theme==="dark"?"light":"dark").

Quitá el ícono/botón de support “?” del topbar.

(Si te falta código de ThemeProvider, usá el que te pasé antes; es corto y probado.)

4.3 Overview (rango + datos reales, sin reload total)

Selector de rango: 24h | 7d | 30d | custom.

Hacé fetch('/api/metrics/overview?range=24h', { credentials:'include' }) y lo mismo para /api/activity/recent-inbound.

Etiquetas:

Accepted Invitations (in range) → window.accepted_invitations

Qualified (in range) → window.qualified

Scheduled (in range) → window.scheduled

TTFR (in range) → (window.ttfr_seconds/60).toFixed(1)+'m'

Active Leads (now) / AI Status (now) / Queue (now) → snapshot.*

Recent Messages: renderizá lo que venga de /api/activity/recent-inbound (3 últimas).

Quick Actions: “Open Chat” → https://chat.incubadoragrowth.com/app/accounts/1/inbox-view y remové “Test agents”.

4.4 Conversations (que sí aparezcan)

Página Conversations debe llamar:

fetch('/api/conversations/list?range=24h', { credentials:'include' })


Renderizá conversation_id, last_message, status, agent_type, updated_at.

Si querés, agregá el mismo selector de rango que en Overview.

4.5 Jobs Queue near-real-time (sin full reload)

Instalamos @tanstack/react-query. Usá useQuery con refetchInterval: 4000 para:

/api/queue/running (lista “processing”)

/api/metrics/overview (contadores pending/processing en snapshot)

Animá cambios:

Números con un hook useAnimatedNumber(value) (interpolación ~400ms).

Filas con framer-motion (AnimatePresence al entrar/salir).

(Si te faltan snippets, usá los que te di en respuestas previas: useAnimatedNumber y ejemplos con framer-motion.)

5) Seguridad / higiene

Quitá cualquier <script src="https://replit.com/public/js/replit-dev-banner.js"> del client/index.html.

Todos los fetch del FE con { credentials:'include' }.

Mantener helmet y express-rate-limit (sobre /auth/login si lo estás usando).

6) Replit Deploy (clave)

En la tarjeta Deploy:

Build command:
npm ci --include=dev && npm run build

Run command:
npm run start

Secrets publicados (Deploy → Sync/Publish secrets):

DATABASE_URL (con sslmode=require)

SESSION_SECRET

ADMIN_KEY

NODE_ENV=production

PORT=5000 (o el que uses)

Importante: --include=dev garantiza que vite/typescript estén durante el build.
En runtime sólo se usa node dist/server/index.js.

7) Verificación final

GET /healthz → { ok: true }

GET /auth/me (logueado) → 200 con {isAuthenticated:true,...}

/ (root): carga la SPA (sin “Cannot GET /”).

Toggle: cambia tema y persiste.

Overview: métricas “(in range)” responden al selector; snapshot “(now)” estable.

Recent Messages: 3 últimos inbound del lead.

Conversations: hay filas reales (ya no “no conversations found”).

Jobs Queue: actualiza suave cada ~4s, con animaciones (sin full reload).

8) Si algo rompe, reglas de oro

No reinstales hacks (bun wrappers, transpilar .tsx al vuelo, HTML temporales).

Si vite “no aparece”, es porque no se instalaron devDeps en build: corregí Build command a npm ci --include=dev && npm run build.

Si ves “Cannot GET /” en producción, revisá que exista dist/public/index.html y que server/index.ts sirva dist/public en NODE_ENV=production.

Si el toggle no hace nada, asegurate que:

ThemeProvider agrega/quita .dark en <html>,

index.css define variables en :root (light) y .dark (dark),

los componentes usan bg-background/text-foreground ó bg-card, etc.