Objetivo: agregar auth real al BFF (cookies HTTP-only + JWT), proteger todas las rutas de la SPA y /api/*, y crear un usuario admin.

0) Suposiciones

Proyecto Node/Express con CommonJS (si package.json NO tiene "type":"module").

Variables en Replit ya creadas: DATABASE_URL, PORT, NODE_ENV=production, INTERNAL_KEY.

Agregar si faltan: SESSION_SECRET (random largo) y ADMIN_KEY (random largo).

1) Instala dependencias (si faltan)

Ejecuta en shell:
npm i cookie-parser jsonwebtoken bcryptjs express-rate-limit

2) Edita index.js (BFF) y reemplaza/une con este código CommonJS

Mantén endpoints previos (/healthz, /api/*) pero aplica el guard requireAuth a todo /api.

Incluye un bootstrap para asegurar la tabla admin_users.

// index.js (CommonJS)
require('dotenv').config();
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');

const app = express();
app.use(helmet());
app.use(cors({ origin: true, credentials: true }));
app.use(express.json({ limit: '1mb' }));
app.use(cookieParser());

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

// --- asegura tabla de usuarios en el arranque ---
async function ensureTables() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS public.admin_users (
      id BIGSERIAL PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'admin',
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );`);
}
ensureTables().catch(console.error);

const JWT_COOKIE = 'sid';
const loginLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 20 });

function signToken(u) {
  return jwt.sign({ sub: u.id, email: u.email, role: u.role }, process.env.SESSION_SECRET, {
    expiresIn: '12h', issuer: 'dashboard',
  });
}
function requireAdmin(req, res, next) {
  if (req.headers['x-admin-key'] !== process.env.ADMIN_KEY) return res.sendStatus(403);
  next();
}
function requireAuth(req, res, next) {
  const raw = req.cookies[JWT_COOKIE] || (req.headers.authorization || '').replace(/^Bearer\\s+/, '');
  if (!raw) return res.status(401).json({ error: 'unauthorized' });
  try { req.user = jwt.verify(raw, process.env.SESSION_SECRET); return next(); }
  catch { return res.status(401).json({ error: 'unauthorized' }); }
}

// --- salud ---
app.get('/healthz', async (_req, res) => {
  try { await pool.query('select 1'); res.json({ ok: true }); }
  catch (e) { res.status(500).json({ ok: false, error: String(e) }); }
});

// --- bootstrap admin (usar con x-admin-key) ---
app.post('/admin/users', requireAdmin, async (req, res) => {
  const { email, password, role = 'admin' } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: 'email/password required' });
  const hash = await bcrypt.hash(password, 12);
  const { rows } = await pool.query(
    `INSERT INTO public.admin_users(email,password_hash,role)
     VALUES ($1,$2,$3)
     ON CONFLICT (email) DO UPDATE SET password_hash=EXCLUDED.password_hash, role=EXCLUDED.role
     RETURNING id,email,role,created_at`,
    [email, hash, role]
  );
  res.json(rows[0]);
});

// --- auth ---
app.post('/auth/login', loginLimiter, async (req, res) => {
  const { email, password } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: 'email/password required' });
  const { rows } = await pool.query(`SELECT * FROM public.admin_users WHERE email=$1 AND is_active=TRUE`, [email]);
  const u = rows[0];
  if (!u || !(await bcrypt.compare(password, u.password_hash))) return res.status(401).json({ error: 'invalid' });
  const token = signToken(u);
  res.cookie(JWT_COOKIE, token, {
    httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production',
    maxAge: 12 * 60 * 60 * 1000, path: '/',
  });
  res.json({ ok: true, email: u.email, role: u.role });
});
app.post('/auth/logout', (req, res) => {
  res.clearCookie(JWT_COOKIE, { sameSite: 'lax', secure: process.env.NODE_ENV === 'production', path: '/' });
  res.json({ ok: true });
});
app.get('/auth/me', requireAuth, (req, res) => {
  res.json({ email: req.user.email, role: req.user.role });
});

// --- protege TODA la API ---
app.use('/api', requireAuth);

// >>> Aquí mantienen/colocan sus endpoints /api existentes (metrics, queue, activity, etc.)

// --- protege rutas del SPA (HTML) ---
app.use((req, res, next) => {
  if (req.path.startsWith('/auth') || req.path.startsWith('/admin') || req.path.startsWith('/assets') || req.path.startsWith('/healthz')) return next();
  if (req.path.startsWith('/api')) return next(); // ya protegido
  if (req.method === 'GET') {
    try { jwt.verify(req.cookies[JWT_COOKIE], process.env.SESSION_SECRET); return next(); }
    catch { return res.redirect('/login'); }
  }
  next();
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`BFF up on :${port}`));

3) Crear página de login en el FE (si no existe)

Crea src/pages/Login.tsx (o la ruta equivalente de tu framework) con:

import { useState } from "react";
export default function Login() {
  const [email, setEmail] = useState(""); const [password, setPassword] = useState(""); const [err, setErr] = useState<string|null>(null);
  const submit = async (e:any) => {
    e.preventDefault(); setErr(null);
    const r = await fetch('/auth/login', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ email, password }), credentials:'include' });
    if (r.ok) window.location.href = '/'; else setErr('Credenciales inválidas');
  };
  return (
    <div className="min-h-screen grid place-items-center bg-zinc-50">
      <form onSubmit={submit} className="w-96 rounded-2xl border bg-white p-6 shadow">
        <h1 className="mb-4 text-xl font-semibold">Iniciar sesión</h1>
        <input className="mb-3 w-full rounded border p-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
        <input className="mb-3 w-full rounded border p-2" placeholder="Password" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
        {err && <div className="mb-2 text-sm text-red-600">{err}</div>}
        <button className="w-full rounded-lg bg-black px-3 py-2 text-white">Entrar</button>
      </form>
    </div>
  );
}


Asegúrate que el router tenga la ruta /login apuntando a ese componente.
En las llamadas fetch('/api/...') del FE usa credentials:'include'.

4) Redeploy/Reiniciar el servidor

Asegúrate de haber añadido los secrets SESSION_SECRET y ADMIN_KEY.

Reinicia/Re-deploy el repl.

5) Crear el usuario admin (con estos datos)

Ejecuta en el Shell de Replit:

curl -s -X POST "https://client-dashboard-tramia.replit.app/admin/users" \
  -H "Content-Type: application/json" \
  -H "x-admin-key: $ADMIN_KEY" \
  -d '{"email":"partners@letsiatomate.com","password":"Aitomate2025"}'


Si el comando devuelve JSON con el email/role, quedó creado.